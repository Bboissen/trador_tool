// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type EventsEventStatus string

const (
	EventsEventStatusPENDING    EventsEventStatus = "PENDING"
	EventsEventStatusPROCESSING EventsEventStatus = "PROCESSING"
	EventsEventStatusPROCESSED  EventsEventStatus = "PROCESSED"
	EventsEventStatusFAILED     EventsEventStatus = "FAILED"
	EventsEventStatusRETRY      EventsEventStatus = "RETRY"
)

func (e *EventsEventStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventsEventStatus(s)
	case string:
		*e = EventsEventStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EventsEventStatus: %T", src)
	}
	return nil
}

type NullEventsEventStatus struct {
	EventsEventStatus EventsEventStatus `json:"events_event_status"`
	Valid             bool              `json:"valid"` // Valid is true if EventsEventStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventsEventStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EventsEventStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventsEventStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventsEventStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventsEventStatus), nil
}

type EventsSagaStatus string

const (
	EventsSagaStatusRUNNING      EventsSagaStatus = "RUNNING"
	EventsSagaStatusCOMPLETED    EventsSagaStatus = "COMPLETED"
	EventsSagaStatusCOMPENSATING EventsSagaStatus = "COMPENSATING"
	EventsSagaStatusFAILED       EventsSagaStatus = "FAILED"
)

func (e *EventsSagaStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventsSagaStatus(s)
	case string:
		*e = EventsSagaStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EventsSagaStatus: %T", src)
	}
	return nil
}

type NullEventsSagaStatus struct {
	EventsSagaStatus EventsSagaStatus `json:"events_saga_status"`
	Valid            bool             `json:"valid"` // Valid is true if EventsSagaStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventsSagaStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EventsSagaStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventsSagaStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventsSagaStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventsSagaStatus), nil
}

type TradingMarginMode string

const (
	TradingMarginModeCROSS    TradingMarginMode = "CROSS"
	TradingMarginModeISOLATED TradingMarginMode = "ISOLATED"
)

func (e *TradingMarginMode) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingMarginMode(s)
	case string:
		*e = TradingMarginMode(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingMarginMode: %T", src)
	}
	return nil
}

type NullTradingMarginMode struct {
	TradingMarginMode TradingMarginMode `json:"trading_margin_mode"`
	Valid             bool              `json:"valid"` // Valid is true if TradingMarginMode is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingMarginMode) Scan(value interface{}) error {
	if value == nil {
		ns.TradingMarginMode, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingMarginMode.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingMarginMode) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingMarginMode), nil
}

type TradingOrderSide string

const (
	TradingOrderSideBUY  TradingOrderSide = "BUY"
	TradingOrderSideSELL TradingOrderSide = "SELL"
)

func (e *TradingOrderSide) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingOrderSide(s)
	case string:
		*e = TradingOrderSide(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingOrderSide: %T", src)
	}
	return nil
}

type NullTradingOrderSide struct {
	TradingOrderSide TradingOrderSide `json:"trading_order_side"`
	Valid            bool             `json:"valid"` // Valid is true if TradingOrderSide is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingOrderSide) Scan(value interface{}) error {
	if value == nil {
		ns.TradingOrderSide, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingOrderSide.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingOrderSide) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingOrderSide), nil
}

type TradingOrderStatus string

const (
	TradingOrderStatusPENDING         TradingOrderStatus = "PENDING"
	TradingOrderStatusOPEN            TradingOrderStatus = "OPEN"
	TradingOrderStatusPARTIALLYFILLED TradingOrderStatus = "PARTIALLY_FILLED"
	TradingOrderStatusFILLED          TradingOrderStatus = "FILLED"
	TradingOrderStatusCANCELLED       TradingOrderStatus = "CANCELLED"
	TradingOrderStatusREJECTED        TradingOrderStatus = "REJECTED"
	TradingOrderStatusEXPIRED         TradingOrderStatus = "EXPIRED"
)

func (e *TradingOrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingOrderStatus(s)
	case string:
		*e = TradingOrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingOrderStatus: %T", src)
	}
	return nil
}

type NullTradingOrderStatus struct {
	TradingOrderStatus TradingOrderStatus `json:"trading_order_status"`
	Valid              bool               `json:"valid"` // Valid is true if TradingOrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TradingOrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingOrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingOrderStatus), nil
}

type TradingOrderTif string

const (
	TradingOrderTifGTC TradingOrderTif = "GTC"
	TradingOrderTifIOC TradingOrderTif = "IOC"
	TradingOrderTifFOK TradingOrderTif = "FOK"
	TradingOrderTifGTD TradingOrderTif = "GTD"
)

func (e *TradingOrderTif) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingOrderTif(s)
	case string:
		*e = TradingOrderTif(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingOrderTif: %T", src)
	}
	return nil
}

type NullTradingOrderTif struct {
	TradingOrderTif TradingOrderTif `json:"trading_order_tif"`
	Valid           bool            `json:"valid"` // Valid is true if TradingOrderTif is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingOrderTif) Scan(value interface{}) error {
	if value == nil {
		ns.TradingOrderTif, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingOrderTif.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingOrderTif) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingOrderTif), nil
}

type TradingOrderType string

const (
	TradingOrderTypeMARKET       TradingOrderType = "MARKET"
	TradingOrderTypeLIMIT        TradingOrderType = "LIMIT"
	TradingOrderTypeSTOP         TradingOrderType = "STOP"
	TradingOrderTypeSTOPLIMIT    TradingOrderType = "STOP_LIMIT"
	TradingOrderTypeTWAP         TradingOrderType = "TWAP"
	TradingOrderTypeDCA          TradingOrderType = "DCA"
	TradingOrderTypeSCALE        TradingOrderType = "SCALE"
	TradingOrderTypeTRAILINGSTOP TradingOrderType = "TRAILING_STOP"
)

func (e *TradingOrderType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingOrderType(s)
	case string:
		*e = TradingOrderType(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingOrderType: %T", src)
	}
	return nil
}

type NullTradingOrderType struct {
	TradingOrderType TradingOrderType `json:"trading_order_type"`
	Valid            bool             `json:"valid"` // Valid is true if TradingOrderType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingOrderType) Scan(value interface{}) error {
	if value == nil {
		ns.TradingOrderType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingOrderType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingOrderType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingOrderType), nil
}

type TradingTransactionStatus string

const (
	TradingTransactionStatusPENDING   TradingTransactionStatus = "PENDING"
	TradingTransactionStatusCONFIRMED TradingTransactionStatus = "CONFIRMED"
	TradingTransactionStatusREVERTED  TradingTransactionStatus = "REVERTED"
	TradingTransactionStatusFAILED    TradingTransactionStatus = "FAILED"
)

func (e *TradingTransactionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TradingTransactionStatus(s)
	case string:
		*e = TradingTransactionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TradingTransactionStatus: %T", src)
	}
	return nil
}

type NullTradingTransactionStatus struct {
	TradingTransactionStatus TradingTransactionStatus `json:"trading_transaction_status"`
	Valid                    bool                     `json:"valid"` // Valid is true if TradingTransactionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTradingTransactionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TradingTransactionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TradingTransactionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTradingTransactionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TradingTransactionStatus), nil
}

type EventsConsumerPosition struct {
	ConsumerGroup       string             `json:"consumer_group"`
	PartitionKey        string             `json:"partition_key"`
	StreamName          string             `json:"stream_name"`
	LastEventID         pgtype.UUID        `json:"last_event_id"`
	LastOffset          pgtype.Int8        `json:"last_offset"`
	LastTimestamp       pgtype.Timestamptz `json:"last_timestamp"`
	ProcessingEventID   pgtype.UUID        `json:"processing_event_id"`
	ProcessingStartedAt pgtype.Timestamptz `json:"processing_started_at"`
	Checkpoint          []byte             `json:"checkpoint"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

type EventsEventStore struct {
	ID            string             `json:"id"`
	AggregateID   string             `json:"aggregate_id"`
	AggregateType string             `json:"aggregate_type"`
	EventType     string             `json:"event_type"`
	EventVersion  int32              `json:"event_version"`
	Payload       []byte             `json:"payload"`
	Metadata      []byte             `json:"metadata"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	CreatedBy     pgtype.Text        `json:"created_by"`
}

type EventsOutbox struct {
	ID            string                `json:"id"`
	AggregateID   string                `json:"aggregate_id"`
	AggregateType string                `json:"aggregate_type"`
	EventType     string                `json:"event_type"`
	Payload       []byte                `json:"payload"`
	Headers       []byte                `json:"headers"`
	Topic         pgtype.Text           `json:"topic"`
	PartitionKey  pgtype.Text           `json:"partition_key"`
	Status        NullEventsEventStatus `json:"status"`
	RetryCount    pgtype.Int4           `json:"retry_count"`
	MaxRetries    pgtype.Int4           `json:"max_retries"`
	CreatedAt     pgtype.Timestamptz    `json:"created_at"`
	ProcessedAt   pgtype.Timestamptz    `json:"processed_at"`
	NextRetryAt   pgtype.Timestamptz    `json:"next_retry_at"`
	ErrorMessage  pgtype.Text           `json:"error_message"`
	ErrorDetails  []byte                `json:"error_details"`
}

type EventsProjection struct {
	ProjectionName     string             `json:"projection_name"`
	LastEventID        pgtype.UUID        `json:"last_event_id"`
	LastEventTimestamp pgtype.Timestamptz `json:"last_event_timestamp"`
	Checkpoint         []byte             `json:"checkpoint"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

type EventsSaga struct {
	ID            string               `json:"id"`
	SagaType      string               `json:"saga_type"`
	CurrentStep   int32                `json:"current_step"`
	TotalSteps    int32                `json:"total_steps"`
	Status        NullEventsSagaStatus `json:"status"`
	Context       []byte               `json:"context"`
	Compensations [][]byte             `json:"compensations"`
	TimeoutAt     pgtype.Timestamptz   `json:"timeout_at"`
	CreatedAt     pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz   `json:"updated_at"`
	CompletedAt   pgtype.Timestamptz   `json:"completed_at"`
}

type EventsSagaStep struct {
	SagaID      string             `json:"saga_id"`
	StepNumber  int32              `json:"step_number"`
	StepName    string             `json:"step_name"`
	Input       []byte             `json:"input"`
	Output      []byte             `json:"output"`
	Error       []byte             `json:"error"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

type EventsSnapshot struct {
	AggregateID   string             `json:"aggregate_id"`
	AggregateType pgtype.Text        `json:"aggregate_type"`
	Version       int32              `json:"version"`
	State         []byte             `json:"state"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

type TradingHealthCheck struct {
	Component           string             `json:"component"`
	Status              string             `json:"status"`
	ResponseTimeMs      pgtype.Int4        `json:"response_time_ms"`
	SuccessRate         pgtype.Numeric     `json:"success_rate"`
	ErrorCount          pgtype.Int4        `json:"error_count"`
	Details             []byte             `json:"details"`
	LastCheck           pgtype.Timestamptz `json:"last_check"`
	ConsecutiveFailures pgtype.Int4        `json:"consecutive_failures"`
}

type TradingNetwork struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	ChainID       int64              `json:"chain_id"`
	IsTestnet     pgtype.Bool        `json:"is_testnet"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	ActivatedAt   pgtype.Timestamptz `json:"activated_at"`
	DeactivatedAt pgtype.Timestamptz `json:"deactivated_at"`
}

type TradingOrder struct {
	ID                   string                `json:"id"`
	StrategyID           int32                 `json:"strategy_id"`
	SourceNetworkID      pgtype.Int4           `json:"source_network_id"`
	DestNetworkID        pgtype.Int4           `json:"dest_network_id"`
	AdapterKey           string                `json:"adapter_key"`
	Status               TradingOrderStatus    `json:"status"`
	IdempotencyKey       string                `json:"idempotency_key"`
	AssetInRef           string                `json:"asset_in_ref"`
	AssetOutRef          string                `json:"asset_out_ref"`
	Side                 TradingOrderSide      `json:"side"`
	Type                 TradingOrderType      `json:"type"`
	Tif                  TradingOrderTif       `json:"tif"`
	ReduceOnly           pgtype.Bool           `json:"reduce_only"`
	PostOnly             pgtype.Bool           `json:"post_only"`
	Leverage             pgtype.Numeric        `json:"leverage"`
	MarginMode           NullTradingMarginMode `json:"margin_mode"`
	AmountIn             pgtype.Numeric        `json:"amount_in"`
	AmountOutMin         pgtype.Numeric        `json:"amount_out_min"`
	FilledAmount         pgtype.Numeric        `json:"filled_amount"`
	LimitPrice           pgtype.Numeric        `json:"limit_price"`
	StopPrice            pgtype.Numeric        `json:"stop_price"`
	AverageFillPrice     pgtype.Numeric        `json:"average_fill_price"`
	SlippageTolerance    pgtype.Numeric        `json:"slippage_tolerance"`
	Version              int32                 `json:"version"`
	EventVersion         int32                 `json:"event_version"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	SubmittedAt          pgtype.Timestamptz    `json:"submitted_at"`
	AckedAt              pgtype.Timestamptz    `json:"acked_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	TriggeredAt          pgtype.Timestamptz    `json:"triggered_at"`
	CompletedAt          pgtype.Timestamptz    `json:"completed_at"`
	ExpiredAt            pgtype.Timestamptz    `json:"expired_at"`
	CanceledAt           pgtype.Timestamptz    `json:"canceled_at"`
	Tags                 []string              `json:"tags"`
	Metadata             []byte                `json:"metadata"`
	ExecutionPreferences []byte                `json:"execution_preferences"`
}

type TradingOrderFill struct {
	ID             string                       `json:"id"`
	OrderID        string                       `json:"order_id"`
	IdempotencyKey string                       `json:"idempotency_key"`
	AmountIn       pgtype.Numeric               `json:"amount_in"`
	AmountOut      pgtype.Numeric               `json:"amount_out"`
	Price          pgtype.Numeric               `json:"price"`
	FeeAmount      pgtype.Numeric               `json:"fee_amount"`
	FeeAssetRef    pgtype.Text                  `json:"fee_asset_ref"`
	AdapterKey     string                       `json:"adapter_key"`
	TxHash         []byte                       `json:"tx_hash"`
	BlockNumber    pgtype.Int8                  `json:"block_number"`
	LogIndex       pgtype.Int4                  `json:"log_index"`
	Status         NullTradingTransactionStatus `json:"status"`
	ConfirmedAt    pgtype.Timestamptz           `json:"confirmed_at"`
	RevertedAt     pgtype.Timestamptz           `json:"reverted_at"`
	ExecutedAt     pgtype.Timestamptz           `json:"executed_at"`
}
