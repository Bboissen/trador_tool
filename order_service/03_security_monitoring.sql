-- 03_security_monitoring.sql
-- Security, RLS policies, audit, and observability
-- Includes: encryption, row-level security, monitoring, alerting

SET search_path TO trading, audit, events, public;

-- ============================================================================
-- AUDIT SCHEMA AND TABLES
-- ============================================================================

CREATE SCHEMA IF NOT EXISTS audit;

-- Comprehensive audit log
CREATE TABLE IF NOT EXISTS audit.activity_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY,
  
  -- Context
  correlation_id UUID DEFAULT trading.uuid_v7(),
  request_id UUID,
  session_id TEXT,
  
  -- Actor
  wallet_id INT,
  user_id TEXT DEFAULT current_user,
  client_ip INET,
  user_agent TEXT,
  api_key_hash BYTEA,
  
  -- Action
  action TEXT NOT NULL,
  table_schema TEXT NOT NULL,
  table_name TEXT NOT NULL,
  record_id TEXT,
  
  -- Data
  old_values JSONB,
  new_values JSONB,
  query TEXT,
  
  -- Result
  status TEXT CHECK (status IN ('SUCCESS', 'FAILED', 'BLOCKED')),
  error_message TEXT,
  
  -- Metadata
  performed_at TIMESTAMPTZ DEFAULT now(),
  execution_time_ms INT,
  
  PRIMARY KEY (performed_at, id)
) PARTITION BY RANGE (performed_at);

-- Create initial partitions
CREATE TABLE audit.activity_log_2024_01 PARTITION OF audit.activity_log
  FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- Error log for security events
CREATE TABLE IF NOT EXISTS audit.security_events (
  id UUID PRIMARY KEY DEFAULT trading.uuid_v7(),
  
  event_type TEXT NOT NULL CHECK (event_type IN (
    'LOGIN_FAILED', 'PERMISSION_DENIED', 'RATE_LIMIT_EXCEEDED',
    'SUSPICIOUS_ACTIVITY', 'DATA_BREACH_ATTEMPT', 'SQL_INJECTION',
    'XSS_ATTEMPT', 'BLACKLIST_HIT', 'ANOMALY_DETECTED'
  )),
  
  severity TEXT NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
  
  -- Context
  wallet_id INT,
  client_ip INET,
  user_agent TEXT,
  request_path TEXT,
  request_method TEXT,
  
  -- Details
  details JSONB NOT NULL,
  threat_score INT CHECK (threat_score BETWEEN 0 AND 100),
  
  -- Response
  action_taken TEXT,
  blocked BOOLEAN DEFAULT false,
  
  occurred_at TIMESTAMPTZ DEFAULT now(),
  resolved_at TIMESTAMPTZ
);

CREATE INDEX idx_security_events_unresolved ON audit.security_events(severity, occurred_at)
WHERE resolved_at IS NULL;

-- ============================================================================
-- ENCRYPTION FUNCTIONS
-- ============================================================================

-- Key derivation for field-level encryption
CREATE OR REPLACE FUNCTION trading.derive_encryption_key(
  p_master_key TEXT,
  p_salt TEXT
) RETURNS TEXT AS $$
BEGIN
  RETURN encode(
    digest(p_master_key || p_salt, 'sha256'),
    'hex'
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Encrypt sensitive data
CREATE OR REPLACE FUNCTION trading.encrypt_sensitive(
  p_data TEXT,
  p_key TEXT DEFAULT NULL
) RETURNS BYTEA AS $$
DECLARE
  v_key TEXT;
BEGIN
  v_key := COALESCE(p_key, current_setting('app.encryption_key', true));
  
  IF v_key IS NULL THEN
    RAISE EXCEPTION 'Encryption key not set';
  END IF;
  
  RETURN pgp_sym_encrypt(
    p_data,
    v_key,
    'compress-algo=2, cipher-algo=aes256'
  );
END;
$$ LANGUAGE plpgsql;

-- Decrypt sensitive data
CREATE OR REPLACE FUNCTION trading.decrypt_sensitive(
  p_data BYTEA,
  p_key TEXT DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
  v_key TEXT;
BEGIN
  v_key := COALESCE(p_key, current_setting('app.encryption_key', true));
  
  IF v_key IS NULL THEN
    RAISE EXCEPTION 'Encryption key not set';
  END IF;
  
  RETURN pgp_sym_decrypt(p_data, v_key);
EXCEPTION
  WHEN OTHERS THEN
    -- Log decryption failure
    INSERT INTO audit.security_events (
      event_type, severity, details
    ) VALUES (
      'DATA_BREACH_ATTEMPT', 'HIGH',
      jsonb_build_object('error', SQLERRM, 'user', current_user)
    );
    RAISE;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ROW LEVEL SECURITY POLICIES
-- ============================================================================

-- Note: RLS policies are defined below after helper functions are created

-- Enable RLS on all critical tables
ALTER TABLE trading.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.order_fills ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.account_balances ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.wallet_addresses ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.balance_reservations ENABLE ROW LEVEL SECURITY;
ALTER TABLE trading.order_book ENABLE ROW LEVEL SECURITY;
ALTER TABLE api.external_ids ENABLE ROW LEVEL SECURITY;
ALTER TABLE api.api_keys ENABLE ROW LEVEL SECURITY;

-- Force RLS for table owners
ALTER TABLE trading.orders FORCE ROW LEVEL SECURITY;
ALTER TABLE trading.order_fills FORCE ROW LEVEL SECURITY;
ALTER TABLE trading.account_balances FORCE ROW LEVEL SECURITY;
ALTER TABLE trading.balance_reservations FORCE ROW LEVEL SECURITY;
ALTER TABLE trading.order_book FORCE ROW LEVEL SECURITY;

-- Helper function to get current wallet context (hardened with search_path)
CREATE OR REPLACE FUNCTION trading.current_wallet_id() 
RETURNS INT AS $$
BEGIN
  RETURN NULLIF(current_setting('app.wallet_id', true), '')::INT;
EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER
   SET search_path = pg_catalog, public, trading;

-- Helper function to check admin role (hardened with search_path)
CREATE OR REPLACE FUNCTION trading.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN pg_has_role(current_user, 'trading_admin', 'member');
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER
   SET search_path = pg_catalog, public, trading;

-- ============================================================================
-- ORDER POLICIES
-- ============================================================================

-- Orders: Read own or admin
CREATE POLICY order_select ON trading.orders
  FOR SELECT USING (
    wallet_id = trading.current_wallet_id() OR
    trading.is_admin()
  );

-- Orders: Insert own with active wallet
CREATE POLICY order_insert ON trading.orders
  FOR INSERT WITH CHECK (
    wallet_id = trading.current_wallet_id() AND
    EXISTS (
      SELECT 1 FROM trading.wallets 
      WHERE id = wallet_id 
        AND deactivated_at IS NULL 
        AND blacklisted_at IS NULL
    )
  );

-- Orders: Update own active orders
CREATE POLICY order_update ON trading.orders
  FOR UPDATE 
  USING (
    wallet_id = trading.current_wallet_id() AND
    status IN ('PENDING', 'ACTIVE', 'PARTIALLY_FILLED')
  )
  WITH CHECK (
    wallet_id = trading.current_wallet_id()
  );

-- Orders: No delete (soft delete only)
CREATE POLICY order_no_delete ON trading.orders
  FOR DELETE USING (false);

-- Order triggers table removed; STOP orders live in trading.orders

-- ============================================================================
-- ORDER BOOK POLICIES
-- ============================================================================

-- Order Book: Public read access
CREATE POLICY order_book_select ON trading.order_book
  FOR SELECT USING (true);

-- Order Book: System operations only
CREATE POLICY order_book_modify ON trading.order_book
  FOR ALL USING (
    trading.is_admin() OR
    current_user = 'trading_system'
  );

-- ============================================================================
-- FILL POLICIES
-- ============================================================================

-- Fills: Read own or admin
CREATE POLICY fill_select ON trading.order_fills
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM trading.orders 
      WHERE id = order_fills.order_id 
        AND wallet_id = trading.current_wallet_id()
    ) OR trading.is_admin()
  );

-- Fills: Insert only by system/admin
CREATE POLICY fill_insert ON trading.order_fills
  FOR INSERT WITH CHECK (
    trading.is_admin() OR
    current_user = 'trading_system'
  );

-- Fills: No update (immutable)
CREATE POLICY fill_no_update ON trading.order_fills
  FOR UPDATE USING (false);

-- Fills: No delete (immutable)
CREATE POLICY fill_no_delete ON trading.order_fills
  FOR DELETE USING (false);

-- ============================================================================
-- BALANCE POLICIES
-- ============================================================================

-- Balances: Read own or admin
CREATE POLICY balance_select ON trading.account_balances
  FOR SELECT USING (
    wallet_id = trading.current_wallet_id() OR
    trading.is_admin()
  );

-- Balances: System operations only
CREATE POLICY balance_modify ON trading.account_balances
  FOR ALL USING (
    trading.is_admin() OR
    current_user = 'trading_system'
  );

-- ============================================================================
-- BALANCE RESERVATIONS POLICIES
-- ============================================================================

-- Reservations: Read own or admin
CREATE POLICY reservation_select ON trading.balance_reservations
  FOR SELECT USING (
    wallet_id = trading.current_wallet_id() OR
    trading.is_admin()
  );

-- Reservations: System operations only (service/admin)
CREATE POLICY reservation_modify ON trading.balance_reservations
  FOR ALL USING (
    trading.is_admin() OR
    current_user = 'trading_system'
  );

-- ============================================================================
-- AUDIT TRIGGERS
-- ============================================================================

-- Optimized audit function with conditional logging
CREATE OR REPLACE FUNCTION audit.log_activity() 
RETURNS TRIGGER AS $$
DECLARE
  v_record_id TEXT;
  v_action TEXT;
  v_should_log BOOLEAN := true;
  v_sample_rate NUMERIC;
BEGIN
  v_action := TG_OP;
  
  -- Implement sampling for high-frequency operations
  IF TG_TABLE_NAME IN ('account_balances', 'cache_invalidations') THEN
    -- Sample 10% of balance updates, 1% of cache invalidations
    v_sample_rate := CASE TG_TABLE_NAME
      WHEN 'account_balances' THEN 0.1
      WHEN 'cache_invalidations' THEN 0.01
      ELSE 1.0
    END;
    
    v_should_log := random() < v_sample_rate;
  END IF;
  
  -- Skip logging for system operations
  IF current_user = 'trading_system' AND TG_TABLE_NAME = 'cache_invalidations' THEN
    v_should_log := false;
  END IF;
  
  IF NOT v_should_log THEN
    RETURN COALESCE(NEW, OLD);
  END IF;
  
  -- Get record ID
  IF TG_OP = 'DELETE' THEN
    v_record_id := COALESCE(
      OLD.id::TEXT,
      row_to_json(OLD)::TEXT
    );
  ELSE
    v_record_id := COALESCE(
      NEW.id::TEXT,
      row_to_json(NEW)::TEXT
    );
  END IF;
  
  -- Log to audit (batch insert for performance)
  INSERT INTO audit.activity_log (
    action, table_schema, table_name, record_id,
    old_values, new_values, wallet_id, status
  ) VALUES (
    v_action,
    TG_TABLE_SCHEMA,
    TG_TABLE_NAME,
    v_record_id,
    CASE 
      WHEN TG_OP IN ('UPDATE', 'DELETE') AND TG_TABLE_NAME NOT IN ('account_balances') 
      THEN to_jsonb(OLD) 
    END,
    CASE 
      WHEN TG_OP IN ('INSERT', 'UPDATE') AND TG_TABLE_NAME NOT IN ('account_balances')
      THEN to_jsonb(NEW) 
    END,
    COALESCE(NEW.wallet_id, OLD.wallet_id, trading.current_wallet_id()),
    'SUCCESS'
  );
  
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- END OF RLS POLICIES
-- ============================================================================

-- Apply audit triggers selectively to critical tables
CREATE TRIGGER audit_orders 
  AFTER INSERT OR UPDATE OR DELETE ON trading.orders
  FOR EACH ROW 
  WHEN (pg_trigger_depth() < 2)  -- Prevent recursive triggers
  EXECUTE FUNCTION audit.log_activity();

CREATE TRIGGER audit_fills
  AFTER INSERT ON trading.order_fills  -- Only INSERT, fills are immutable
  FOR EACH ROW 
  WHEN (pg_trigger_depth() < 2)
  EXECUTE FUNCTION audit.log_activity();

CREATE TRIGGER audit_balances
  AFTER UPDATE ON trading.account_balances  -- Only UPDATE, not INSERT/DELETE
  FOR EACH ROW 
  WHEN (OLD.available IS DISTINCT FROM NEW.available OR 
        OLD.reserved IS DISTINCT FROM NEW.reserved)
  EXECUTE FUNCTION audit.log_activity();

-- order_triggers audit trigger removed (table no longer exists)

-- ============================================================================
-- ANOMALY DETECTION
-- ============================================================================

-- Detect suspicious patterns
CREATE OR REPLACE FUNCTION audit.detect_anomalies()
RETURNS TABLE(
  anomaly_type TEXT,
  wallet_id INT,
  severity TEXT,
  details JSONB
) AS $$
BEGIN
  -- Rapid order creation
  RETURN QUERY
  SELECT 
    'RAPID_ORDER_CREATION',
    o.wallet_id,
    CASE 
      WHEN COUNT(*) > 100 THEN 'HIGH'
      WHEN COUNT(*) > 50 THEN 'MEDIUM'
      ELSE 'LOW'
    END,
    jsonb_build_object(
      'order_count', COUNT(*),
      'time_window', '1 minute'
    )
  FROM trading.orders o
  WHERE o.created_at > now() - INTERVAL '1 minute'
  GROUP BY o.wallet_id
  HAVING COUNT(*) > 10;
  
  -- Large balance changes
  RETURN QUERY
  SELECT 
    'LARGE_BALANCE_CHANGE',
    ab.wallet_id,
    'HIGH',
    jsonb_build_object(
      'token_id', ab.token_id,
      'change_percent', 
        ABS(ab.available - lag(ab.available) OVER (PARTITION BY ab.wallet_id, ab.token_id ORDER BY ab.updated_at)) 
        / NULLIF(lag(ab.available) OVER (PARTITION BY ab.wallet_id, ab.token_id ORDER BY ab.updated_at), 0) * 100
    )
  FROM trading.account_balances ab
  WHERE ab.updated_at > now() - INTERVAL '5 minutes'
    AND ABS(ab.available - lag(ab.available) OVER (PARTITION BY ab.wallet_id, ab.token_id ORDER BY ab.updated_at)) 
        / NULLIF(lag(ab.available) OVER (PARTITION BY ab.wallet_id, ab.token_id ORDER BY ab.updated_at), 0) > 0.5;
  
  -- Failed login attempts
  RETURN QUERY
  SELECT 
    'MULTIPLE_FAILED_LOGINS',
    se.wallet_id,
    'MEDIUM',
    jsonb_build_object(
      'attempt_count', COUNT(*),
      'ip_addresses', array_agg(DISTINCT se.client_ip)
    )
  FROM audit.security_events se
  WHERE se.event_type = 'LOGIN_FAILED'
    AND se.occurred_at > now() - INTERVAL '10 minutes'
  GROUP BY se.wallet_id
  HAVING COUNT(*) > 5;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- MONITORING VIEWS
-- ============================================================================

-- System health dashboard
CREATE OR REPLACE VIEW audit.v_system_health AS
SELECT 
  'database_size' as metric,
  pg_database_size(current_database())::TEXT as value,
  'bytes' as unit
UNION ALL
SELECT 
  'active_connections',
  COUNT(*)::TEXT,
  'count'
FROM pg_stat_activity
WHERE state = 'active'
UNION ALL
SELECT 
  'pending_orders',
  COUNT(*)::TEXT,
  'count'
FROM trading.orders
WHERE status IN ('PENDING', 'ACTIVE')
UNION ALL
SELECT 
  'error_rate_1h',
  COUNT(*)::TEXT,
  'count'
FROM audit.security_events
WHERE occurred_at > now() - INTERVAL '1 hour'
  AND severity IN ('HIGH', 'CRITICAL');

-- Security metrics
CREATE OR REPLACE VIEW audit.v_security_metrics AS
WITH hourly_stats AS (
  SELECT 
    date_trunc('hour', occurred_at) as hour,
    event_type,
    COUNT(*) as event_count,
    MAX(threat_score) as max_threat_score
  FROM audit.security_events
  WHERE occurred_at > now() - INTERVAL '24 hours'
  GROUP BY 1, 2
)
SELECT 
  hour,
  jsonb_object_agg(event_type, event_count) as events_by_type,
  SUM(event_count) as total_events,
  MAX(max_threat_score) as peak_threat_score
FROM hourly_stats
GROUP BY hour
ORDER BY hour DESC;

-- User activity summary
CREATE OR REPLACE VIEW audit.v_user_activity AS
SELECT 
  wallet_id,
  COUNT(DISTINCT session_id) as session_count,
  COUNT(*) as action_count,
  array_agg(DISTINCT action) as actions_performed,
  MIN(performed_at) as first_seen,
  MAX(performed_at) as last_seen,
  COUNT(DISTINCT client_ip) as unique_ips
FROM audit.activity_log
WHERE performed_at > now() - INTERVAL '7 days'
GROUP BY wallet_id;

-- ============================================================================
-- PERFORMANCE MONITORING
-- ============================================================================

-- Query performance tracking
CREATE TABLE IF NOT EXISTS audit.query_performance (
  id UUID PRIMARY KEY DEFAULT trading.uuid_v7(),
  
  query_hash BIGINT NOT NULL,
  query_text TEXT,
  
  -- Metrics
  execution_count BIGINT DEFAULT 1,
  total_time_ms NUMERIC,
  mean_time_ms NUMERIC,
  max_time_ms NUMERIC,
  min_time_ms NUMERIC,
  stddev_time_ms NUMERIC,
  
  -- Resource usage
  rows_returned BIGINT,
  blocks_hit BIGINT,
  blocks_read BIGINT,
  
  -- Context
  database TEXT DEFAULT current_database(),
  user_name TEXT DEFAULT current_user,
  
  first_seen TIMESTAMPTZ DEFAULT now(),
  last_seen TIMESTAMPTZ DEFAULT now()
);

-- Enhanced query stats collection with categorization
CREATE OR REPLACE FUNCTION audit.collect_query_stats(p_threshold_ms NUMERIC DEFAULT 100)
RETURNS TABLE(collected INT, slow_queries INT) AS $$
DECLARE
  v_collected INT := 0;
  v_slow INT := 0;
BEGIN
  -- Reset stats periodically for accuracy
  IF random() < 0.01 THEN  -- 1% chance
    PERFORM pg_stat_statements_reset();
  END IF;
  
  WITH stats AS (
    INSERT INTO audit.query_performance (
      query_hash, query_text, execution_count,
      total_time_ms, mean_time_ms, max_time_ms,
      rows_returned, blocks_hit, blocks_read
    )
    SELECT 
      queryid,
      LEFT(query, 2000),  -- Truncate very long queries
      calls,
      total_exec_time,
      mean_exec_time,
      max_exec_time,
      rows,
      shared_blks_hit,
      shared_blks_read
    FROM pg_stat_statements
    WHERE mean_exec_time > p_threshold_ms  -- Only slow queries
      AND query NOT LIKE '%pg_stat_statements%'  -- Exclude meta queries
      AND query NOT LIKE '%audit.%'  -- Exclude audit queries
    ON CONFLICT (query_hash) DO UPDATE
    SET 
      execution_count = query_performance.execution_count + EXCLUDED.execution_count,
      total_time_ms = query_performance.total_time_ms + EXCLUDED.total_time_ms,
      mean_time_ms = EXCLUDED.mean_time_ms,
      max_time_ms = GREATEST(query_performance.max_time_ms, EXCLUDED.max_time_ms),
      last_seen = now()
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_collected FROM stats;
  
  -- Count current slow queries
  SELECT COUNT(*) INTO v_slow
  FROM audit.query_performance
  WHERE mean_time_ms > p_threshold_ms * 10  -- Very slow
    AND last_seen > now() - INTERVAL '1 hour';
  
  RETURN QUERY SELECT v_collected, v_slow;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ALERTING SYSTEM
-- ============================================================================

-- Alert rules configuration
CREATE TABLE IF NOT EXISTS audit.alert_rules (
  id UUID PRIMARY KEY DEFAULT trading.uuid_v7(),
  
  rule_name TEXT NOT NULL UNIQUE,
  rule_type TEXT NOT NULL CHECK (rule_type IN ('THRESHOLD', 'ANOMALY', 'PATTERN')),
  
  -- Condition
  metric_query TEXT NOT NULL,
  condition TEXT NOT NULL CHECK (condition IN ('>', '<', '>=', '<=', '=', '!=')),
  threshold NUMERIC NOT NULL,
  
  -- Alert details
  severity TEXT NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
  message_template TEXT NOT NULL,
  
  -- Configuration
  enabled BOOLEAN DEFAULT true,
  check_interval_seconds INT DEFAULT 60,
  
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Alert history
CREATE TABLE IF NOT EXISTS audit.alert_history (
  id UUID PRIMARY KEY DEFAULT trading.uuid_v7(),
  
  rule_id UUID REFERENCES audit.alert_rules(id),
  
  -- Alert details
  severity TEXT NOT NULL,
  message TEXT NOT NULL,
  metric_value NUMERIC,
  
  -- Status
  status TEXT CHECK (status IN ('TRIGGERED', 'ACKNOWLEDGED', 'RESOLVED')),
  
  triggered_at TIMESTAMPTZ DEFAULT now(),
  acknowledged_at TIMESTAMPTZ,
  resolved_at TIMESTAMPTZ,
  
  -- Response
  acknowledged_by TEXT,
  resolution_notes TEXT
);

-- Function to check alerts
CREATE OR REPLACE FUNCTION audit.check_alerts()
RETURNS TABLE(
  rule_name TEXT,
  triggered BOOLEAN,
  metric_value NUMERIC,
  message TEXT
) AS $$
DECLARE
  v_rule RECORD;
  v_value NUMERIC;
  v_triggered BOOLEAN;
BEGIN
  FOR v_rule IN 
    SELECT * FROM audit.alert_rules 
    WHERE enabled = true
  LOOP
    -- Execute metric query
    EXECUTE v_rule.metric_query INTO v_value;
    
    -- Check condition
    EXECUTE format('SELECT %s %s %s', v_value, v_rule.condition, v_rule.threshold)
    INTO v_triggered;
    
    IF v_triggered THEN
      -- Record alert
      INSERT INTO audit.alert_history (
        rule_id, severity, message, metric_value
      ) VALUES (
        v_rule.id,
        v_rule.severity,
        format(v_rule.message_template, v_value),
        v_value
      );
      
      -- Notify
      PERFORM pg_notify('alert', json_build_object(
        'rule', v_rule.rule_name,
        'severity', v_rule.severity,
        'value', v_value,
        'message', format(v_rule.message_template, v_value)
      )::TEXT);
    END IF;
    
    RETURN QUERY SELECT 
      v_rule.rule_name,
      v_triggered,
      v_value,
      format(v_rule.message_template, v_value);
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- DEFAULT ALERT RULES
-- ============================================================================

INSERT INTO audit.alert_rules (rule_name, rule_type, metric_query, condition, threshold, severity, message_template)
VALUES 
  ('high_error_rate', 'THRESHOLD', 
   'SELECT COUNT(*) FROM audit.security_events WHERE occurred_at > now() - INTERVAL ''5 minutes'' AND severity IN (''HIGH'', ''CRITICAL'')',
   '>', 10, 'HIGH', 'High error rate detected: %s errors in 5 minutes'),
   
  ('connection_saturation', 'THRESHOLD',
   'SELECT COUNT(*) FROM pg_stat_activity WHERE state = ''active''',
   '>', 150, 'CRITICAL', 'Database connection saturation: %s active connections'),
   
  ('slow_query_spike', 'THRESHOLD',
   'SELECT COUNT(*) FROM pg_stat_statements WHERE mean_exec_time > 1000 AND calls > 10',
   '>', 20, 'MEDIUM', 'Slow query spike detected: %s slow queries'),
   
  ('suspicious_activity', 'ANOMALY',
   'SELECT COUNT(DISTINCT wallet_id) FROM audit.security_events WHERE event_type = ''SUSPICIOUS_ACTIVITY'' AND occurred_at > now() - INTERVAL ''10 minutes''',
   '>', 5, 'HIGH', 'Suspicious activity detected from %s wallets'),
   
  ('disk_space_warning', 'THRESHOLD',
   'SELECT (pg_database_size(current_database()) / 1073741824.0)::NUMERIC',  -- GB
   '>', 100, 'MEDIUM', 'Database size warning: %s GB used')
   
ON CONFLICT (rule_name) DO NOTHING;

-- ============================================================================
-- DATA MASKING FUNCTIONS
-- ============================================================================

-- Mask sensitive wallet data
CREATE OR REPLACE FUNCTION audit.mask_wallet_data(p_wallet JSONB)
RETURNS JSONB AS $$
BEGIN
  RETURN p_wallet - ARRAY['risk_score', 'blacklist_reason'] || 
         jsonb_build_object(
           'id', (p_wallet->>'id')::INT,
           'masked', true
         );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Mask order details
CREATE OR REPLACE FUNCTION audit.mask_order_data(p_order JSONB)
RETURNS JSONB AS $$
BEGIN
  RETURN jsonb_build_object(
    'id', p_order->>'id',
    'status', p_order->>'status',
    'side', p_order->>'side',
    'type', p_order->>'type',
    'created_at', p_order->>'created_at',
    'amount_masked', true
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================================================
-- PERFORMANCE MONITORING VIEWS
-- ============================================================================

-- Real-time query performance view
CREATE OR REPLACE VIEW audit.v_query_performance AS
SELECT 
  query_hash,
  LEFT(query_text, 100) as query_preview,
  execution_count,
  ROUND(mean_time_ms::NUMERIC, 2) as avg_ms,
  ROUND(max_time_ms::NUMERIC, 2) as max_ms,
  ROUND((total_time_ms / 1000)::NUMERIC, 2) as total_seconds,
  ROUND((rows_returned::NUMERIC / NULLIF(execution_count, 0)), 2) as avg_rows,
  ROUND(100.0 * blocks_hit / NULLIF(blocks_hit + blocks_read, 0), 2) as cache_hit_ratio,
  last_seen
FROM audit.query_performance
WHERE last_seen > now() - INTERVAL '24 hours'
ORDER BY total_time_ms DESC
LIMIT 50;

-- Table bloat monitoring
CREATE OR REPLACE VIEW audit.v_table_bloat AS
SELECT 
  schemaname,
  tablename,
  (pg_total_relation_size(schemaname||'.'||tablename)) as total_size_bytes,
  ROUND(CASE WHEN otta=0 THEN 0.0 ELSE ((relpages-otta)::NUMERIC/relpages)*100 END, 2) as bloat_percent,
  ((relpages-otta)*8192) as bloat_size_bytes
FROM (
  SELECT 
    schemaname,
    tablename,
    cc.relpages,
    CEIL((cc.reltuples*((datahdr+24+CASE WHEN datahdr%8=0 THEN 8 ELSE datahdr%8 END)::NUMERIC))/(8192-20)) AS otta
  FROM (
    SELECT 
      ns.nspname AS schemaname,
      tbl.relname AS tablename,
      tbl.relpages,
      tbl.reltuples,
      24 AS datahdr
    FROM pg_class tbl
    JOIN pg_namespace ns ON ns.oid = tbl.relnamespace
    WHERE ns.nspname IN ('trading', 'events', 'audit')
      AND tbl.relkind = 'r'
  ) AS cc
) AS bloat_calc
WHERE relpages > 10  -- Only tables with more than 10 pages
ORDER BY (relpages-otta) DESC;

-- ============================================================================
-- COMPLIANCE REPORTING
-- ============================================================================

-- Daily compliance report
CREATE OR REPLACE FUNCTION audit.generate_compliance_report(p_date DATE DEFAULT CURRENT_DATE)
RETURNS JSONB AS $$
DECLARE
  v_report JSONB;
BEGIN
  SELECT jsonb_build_object(
    'report_date', p_date,
    'generated_at', now(),
    
    'trading_volume', (
      SELECT jsonb_build_object(
        'total_orders', COUNT(*),
        'total_value', SUM(amount_in),
        'unique_wallets', COUNT(DISTINCT wallet_id)
      )
      FROM trading.orders
      WHERE DATE(created_at) = p_date
    ),
    
    'security_events', (
      SELECT jsonb_object_agg(severity, count)
      FROM (
        SELECT severity, COUNT(*) as count
        FROM audit.security_events
        WHERE DATE(occurred_at) = p_date
        GROUP BY severity
      ) s
    ),
    
    'suspicious_wallets', (
      SELECT jsonb_agg(wallet_id)
      FROM (
        SELECT DISTINCT wallet_id
        FROM audit.security_events
        WHERE DATE(occurred_at) = p_date
          AND severity IN ('HIGH', 'CRITICAL')
      ) w
    ),
    
    'system_health', (
      SELECT jsonb_object_agg(metric, value)
      FROM audit.v_system_health
    )
  ) INTO v_report;
  
  RETURN v_report;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- END OF SECURITY AND MONITORING
-- ============================================================================
