-- 01_complete_setup.sql
-- Complete PostgreSQL 17.6 optimized setup for modern trading system
-- Includes: schemas, types, tables, partitioning, event sourcing
-- Designed for: Kubernetes, Kafka 4.1, Rust 1.89

-- ============================================================================
-- NOTE: Cluster/server configuration and extensions are managed by SRE/DBA.
-- All ALTER SYSTEM / CREATE EXTENSION / ROLE GRANTS have been moved to
-- 00_infra_superuser.sql and should not be applied by app migrations.
-- ============================================================================

-- ============================================================================
-- SCHEMAS
-- ============================================================================

CREATE SCHEMA IF NOT EXISTS trading;   -- Core trading domain
CREATE SCHEMA IF NOT EXISTS events;    -- Event sourcing
CREATE SCHEMA IF NOT EXISTS audit;     -- Audit and compliance
CREATE SCHEMA IF NOT EXISTS api;       -- API layer

SET search_path TO trading, events, public;

-- ============================================================================
-- EXTENSIONS
-- ============================================================================
-- Managed by infra in 00_infra_superuser.sql

-- ============================================================================
-- CUSTOM TYPES
-- ============================================================================

-- Core enums
CREATE TYPE trading.order_side AS ENUM ('BUY', 'SELL');
CREATE TYPE trading.order_type AS ENUM ('MARKET', 'LIMIT', 'STOP', 'STOP_LIMIT', 'TWAP', 'DCA', 'SCALE', 'TRAILING_STOP');
CREATE TYPE trading.order_tif AS ENUM ( 'GTC', 'IOC', 'FOK', 'GTD');
CREATE TYPE trading.margin_mode AS ENUM ('CROSS', 'ISOLATED');

-- Order lifecycle status
CREATE TYPE trading.order_status AS ENUM ('PENDING', 'OPEN', 'PARTIALLY_FILLED', 'FILLED', 'CANCELLED', 'REJECTED', 'EXPIRED');

-- Missing in original: transaction status for fills
CREATE TYPE trading.transaction_status AS ENUM ('PENDING', 'CONFIRMED', 'REVERTED', 'FAILED');


-- Event types
CREATE TYPE events.event_status AS ENUM ('PENDING', 'PROCESSING', 'PROCESSED', 'FAILED', 'RETRY');
CREATE TYPE events.saga_status AS ENUM ('RUNNING', 'COMPLETED', 'COMPENSATING', 'FAILED');

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Distributed ID generator (Snowflake-like)
CREATE SEQUENCE IF NOT EXISTS trading.global_id_seq;

CREATE OR REPLACE FUNCTION trading.generate_distributed_id()
RETURNS BIGINT AS $$
DECLARE
  v_timestamp BIGINT;
  v_sequence_bits INT := 12;
  v_sequence BIGINT;
BEGIN
  v_timestamp := extract(epoch from clock_timestamp()) * 1000;
  v_sequence := nextval('trading.global_id_seq') % (1 << v_sequence_bits);
  
  RETURN (v_timestamp << v_sequence_bits) |
         v_sequence;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- ADVANCED UTILITY FUNCTIONS
-- ============================================================================

-- Advisory lock functions for race condition prevention
CREATE OR REPLACE FUNCTION trading.acquire_order_lock(p_order_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN pg_try_advisory_lock(hashtext(p_order_id::TEXT));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION trading.release_order_lock(p_order_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN pg_advisory_unlock(hashtext(p_order_id::TEXT));
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- CORE TABLES
-- ============================================================================

-- Networks configuration
CREATE TABLE trading.networks (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT UNIQUE NOT NULL CHECK (name ~ '^[a-z][a-z0-9_-]{1,31}$'),
  chain_id BIGINT UNIQUE NOT NULL CHECK (chain_id > 0),
  is_testnet BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT now(),
  activated_at TIMESTAMPTZ DEFAULT now(),
  deactivated_at TIMESTAMPTZ
);

-- ============================================================================
-- EVENT SOURCING
-- ============================================================================

-- Event store partitioned by hash for better distribution
CREATE TABLE events.event_store (
  id UUID DEFAULT gen_random_uuid(),
  aggregate_id UUID NOT NULL,
  aggregate_type TEXT NOT NULL,
  event_type TEXT NOT NULL,
  event_version INT NOT NULL,
  
  payload JSONB NOT NULL,
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ DEFAULT now(),
  created_by TEXT DEFAULT current_user,
  
  -- Composite primary key for hash partitioning
  PRIMARY KEY (id, aggregate_id),
  -- Optimistic concurrency control
  UNIQUE (aggregate_id, event_version)
) PARTITION BY HASH (aggregate_id);

-- Create hash partitions for event store (64 partitions for scalability)
DO $$
BEGIN
  FOR i IN 0..63 LOOP
    EXECUTE format('CREATE TABLE events.event_store_h%s PARTITION OF events.event_store FOR VALUES WITH (modulus 64, remainder %s)', i, i);
  END LOOP;
END $$;

-- Event projections tracking
CREATE TABLE events.projections (
  projection_name TEXT PRIMARY KEY,
  last_event_id UUID,
  last_event_timestamp TIMESTAMPTZ,
  checkpoint JSONB,
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Consumer positions for event streaming
CREATE TABLE events.consumer_positions (
  consumer_group TEXT NOT NULL,
  partition_key TEXT NOT NULL,
  stream_name TEXT NOT NULL DEFAULT 'main',
  
  last_event_id UUID,
  last_offset BIGINT,
  last_timestamp TIMESTAMPTZ,
  
  -- For exactly-once processing
  processing_event_id UUID,
  processing_started_at TIMESTAMPTZ,
  
  checkpoint JSONB DEFAULT '{}',
  updated_at TIMESTAMPTZ DEFAULT now(),
  
  PRIMARY KEY (consumer_group, partition_key, stream_name)
);

-- Snapshots for event sourcing
CREATE TABLE events.snapshots (
  aggregate_id UUID,
  aggregate_type TEXT,
  version INT,
  state JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (aggregate_id, version)
);

-- ============================================================================
-- ORDERS (Event-sourced with CQRS read model)
-- ============================================================================


-- Read model (optimized for queries)
CREATE TABLE trading.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Core references
  strategy_id INT NOT NULL,
  source_network_id INT REFERENCES trading.networks(id),
  dest_network_id INT REFERENCES trading.networks(id),
  adapter_key TEXT NOT NULL,
  status trading.order_status DEFAULT 'PENDING' NOT NULL,
  
  -- Identifiers
  idempotency_key TEXT UNIQUE NOT NULL,
  
  -- Assets (adapter-facing refs)
  asset_in_ref TEXT NOT NULL,
  asset_out_ref TEXT NOT NULL,
  
  -- Order details
  side trading.order_side NOT NULL,
  type trading.order_type NOT NULL,
  tif trading.order_tif NOT NULL,
  reduce_only BOOLEAN DEFAULT false,
  post_only BOOLEAN DEFAULT false,
  leverage NUMERIC(10,4),
  margin_mode trading.margin_mode,
  
  -- Amounts
  amount_in NUMERIC(78,0) NOT NULL CHECK (amount_in > 0),
  amount_out_min NUMERIC(78,0),
  filled_amount NUMERIC(78,0) DEFAULT 0,
  
  -- Pricing
  limit_price NUMERIC(38,18),
  stop_price NUMERIC(38,18),
  average_fill_price NUMERIC(38,18),
  slippage_tolerance NUMERIC(5,4),
  
  -- Concurrency/versioning
  version INT NOT NULL DEFAULT 0,
  event_version INT NOT NULL DEFAULT 0,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT now(),
  submitted_at TIMESTAMPTZ,
  acked_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ DEFAULT now(),
  triggered_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  expired_at TIMESTAMPTZ,
  canceled_at TIMESTAMPTZ,
  
  -- Metadata
  tags TEXT[],
  metadata JSONB DEFAULT '{}',
  execution_preferences JSONB DEFAULT '{}',
  
  -- Constraints
  CHECK (filled_amount >= 0 AND filled_amount <= amount_in),
  -- Order type specific price rules
  CHECK (type != 'MARKET' OR (limit_price IS NULL AND stop_price IS NULL)),
  CHECK (type != 'LIMIT' OR (limit_price IS NOT NULL AND stop_price IS NULL)),
  CHECK (type != 'STOP' OR (stop_price IS NOT NULL AND limit_price IS NULL)),
  CHECK (type != 'STOP_LIMIT' OR (limit_price IS NOT NULL AND stop_price IS NOT NULL)),
  -- TIF compatibility
  CHECK (tif NOT IN ('IOC','FOK') OR post_only = false),
  -- Value domain constraints
  CHECK (limit_price IS NULL OR limit_price > 0),
  CHECK (stop_price IS NULL OR stop_price > 0),
  CHECK (slippage_tolerance IS NULL OR (slippage_tolerance >= 0 AND slippage_tolerance <= 1)),
  CHECK (leverage IS NULL OR leverage > 0),
  CHECK (amount_out_min IS NULL OR amount_out_min >= 0),
  
  -- Unique constraint for idempotency
  CONSTRAINT orders_idempotency_unique UNIQUE (idempotency_key)
);

-- Order fills
CREATE TABLE trading.order_fills (
  id UUID DEFAULT gen_random_uuid() NOT NULL,
  order_id UUID NOT NULL REFERENCES trading.orders(id),
  
  -- Deduplication
  idempotency_key TEXT NOT NULL,
  
  -- Fill details
  amount_in NUMERIC(78,0) NOT NULL CHECK (amount_in > 0),
  amount_out NUMERIC(78,0) NOT NULL CHECK (amount_out > 0),
  price NUMERIC(38,18) NOT NULL,
  fee_amount NUMERIC(78,0) DEFAULT 0,
  fee_asset_ref TEXT,
  
  -- Execution
  adapter_key TEXT NOT NULL,
  tx_hash BYTEA,
  block_number BIGINT,
  log_index INT,
  
  -- Status
  status trading.transaction_status DEFAULT 'PENDING',
  confirmed_at TIMESTAMPTZ,
  reverted_at TIMESTAMPTZ,
  
  executed_at TIMESTAMPTZ DEFAULT now(),
  
  PRIMARY KEY (id, executed_at),
  CONSTRAINT order_fills_order_idempotency UNIQUE (order_id, idempotency_key)
) PARTITION BY RANGE (executed_at);

-- ============================================================================
-- OUTBOX PATTERN (For Kafka CDC)
-- ============================================================================

CREATE TABLE events.outbox (
  id UUID DEFAULT gen_random_uuid(),
  
  -- Event info
  aggregate_id UUID NOT NULL,
  aggregate_type TEXT NOT NULL,
  event_type TEXT NOT NULL,
  
  -- Payload
  payload JSONB NOT NULL,
  headers JSONB DEFAULT '{}',
  
  -- Generated columns for Debezium optimization
  topic TEXT GENERATED ALWAYS AS (lower(aggregate_type) || '.' || lower(event_type)) STORED,
  partition_key TEXT GENERATED ALWAYS AS (aggregate_id::TEXT) STORED,
  
  -- Processing
  status events.event_status DEFAULT 'PENDING',
  retry_count INT DEFAULT 0,
  max_retries INT DEFAULT 3,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT now(),
  processed_at TIMESTAMPTZ,
  next_retry_at TIMESTAMPTZ,
  
  -- Error tracking
  error_message TEXT,
  error_details JSONB,
  PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Note: Partitions are now managed by auto_create_partitions() function
-- No hardcoded partitions needed

-- ============================================================================
-- SAGA PATTERN
-- ============================================================================

CREATE TABLE events.sagas (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  saga_type TEXT NOT NULL,
  
  -- State machine
  current_step INT NOT NULL DEFAULT 0,
  total_steps INT NOT NULL,
  status events.saga_status DEFAULT 'RUNNING',
  
  -- Data
  context JSONB NOT NULL DEFAULT '{}',
  compensations JSONB[] DEFAULT '{}',
  
  -- Timing
  timeout_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  completed_at TIMESTAMPTZ
);

-- Saga steps log
CREATE TABLE events.saga_steps (
  saga_id UUID REFERENCES events.sagas(id),
  step_number INT NOT NULL,
  step_name TEXT NOT NULL,
  
  input JSONB,
  output JSONB,
  error JSONB,
  
  started_at TIMESTAMPTZ DEFAULT now(),
  completed_at TIMESTAMPTZ,
  
  PRIMARY KEY (saga_id, step_number)
);

-- ============================================================================
-- HEALTH MONITORING (For Kubernetes)
-- ============================================================================

CREATE TABLE trading.health_checks (
  component TEXT PRIMARY KEY,
  status TEXT NOT NULL CHECK (status IN ('HEALTHY', 'DEGRADED', 'UNHEALTHY')),
  
  -- Metrics
  response_time_ms INT,
  success_rate NUMERIC(5,2),
  error_count INT DEFAULT 0,
  
  -- Details
  details JSONB DEFAULT '{}',
  
  last_check TIMESTAMPTZ DEFAULT now(),
  consecutive_failures INT DEFAULT 0
);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Update timestamp trigger
CREATE OR REPLACE FUNCTION trading.update_timestamp() 
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to relevant tables
CREATE TRIGGER trg_orders_updated BEFORE UPDATE ON trading.orders 
  FOR EACH ROW EXECUTE FUNCTION trading.update_timestamp();

-- balances trigger removed

-- Note: Outbox events are emitted explicitly in business functions.

-- ============================================================================
-- INITIAL DATA
-- ============================================================================

-- Health check components
INSERT INTO trading.health_checks (component, status) VALUES
  ('database', 'HEALTHY'),
  ('event_bus', 'HEALTHY')
ON CONFLICT DO NOTHING;

-- GRANTS and role management are handled by infra in 00_infra_superuser.sql

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

-- Performance settings
ALTER TABLE trading.orders SET (
  autovacuum_vacuum_scale_factor = 0.01,
  autovacuum_analyze_scale_factor = 0.01,
  fillfactor = 90
);

